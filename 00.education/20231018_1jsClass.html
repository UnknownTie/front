<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>window기본 js </title>
  <link rel="stylesheet" href="./20231018_1jsClass.css">
  <!-- <script src="./20231018_1jsClass.js"></script> -->


  <script>
    function demoReset(){
      console.clear();
      document.getElementById("demo").innerHTML ="";
    }
  </script>
  <!-- 1 -->
  <script>
    'use strict';
  
      // 클래스 생성
    class Member {
      // 필드명 
      //생략가능 (#이 있는 형태는 불가)
      fieldA; 

      //생성자 
      //class 생성시, 실행 
      //1. constructor의 속성을 다르게 중복 생성 X
      //2. class 생성시,  앞에서부터 매개변수 삽입
      // 변수 삽입이 많으면 : 매개변수 개수보다 많은 변수는 사라진다.
      // 변수 삽입이 적으면 : 변수가 삽입이 안된 매개변수는 undefined 처리 된다.
      // constructor() {   } 
      //1. 매개변수 적은 케이스 
      constructor(A1, A2 ) { 
        this.fieldA = A1; 
        this.functionA = A2;
      }

      //1. 매개변수 많은 케이스 
      // constructor(A1, A2 ,A3, A4 ) { 
      //   this.fieldA = A1; 
      //   this.functionA = A2;
      //   this.getTestA = A3; 
      //   this.getTestB = A4;
      // }

      //get , set 조건 (get과 set은 무조건 함께 써야된다.)
      //get,set은 _A ,#A 처럼 같은 변수로 사용해야된다.
      //         A 직접 삽입시, 자신이 자신을 호출하여 무한 반복이 발생한다. 

      //1. #A형태 : 외부에서 #A 접근 불가, private가 된다.
      #getTestA; //외부 사용 : getTestA , 데이터 프로퍼티
      get getTestA() { //접근자  프로퍼티
        console.log("  get privateA()");
        return this.#getTestA;
      }
      // setter 생성
      set setTestA(A) {
        console.log("  set privateA(A) " + A );
        if(A < 1) A = 1;
        this.#getTestA = A;
      }
      
      //2. _A형태 : 외부에서 _A 접근 후 수정가능
      //외부 사용 : getTestB
      get getTestB() {
        console.log("  get privateA()");
        return this._getTestB;
      }
      set SetTestB(A) {
        console.log("  set privateA(A) " + A );
        if(A < 1) A = 1;
        this._getTestB = A;
      }

      //Error A형태 , 무한 반복 -------------
      get getError() {
        console.log("  get getError()");
        return this.getError;
      }
      // setter 생성
      set getError(A) {
        console.log("  set getError(A) " + A );
        if(A < 1) A = 1;
        this.getError = A;
      }
      //----------------------------------------
      
      // 자식 클래스는 생성자 X 
      // 생성자
      // constructor() {}

  
      // 메소드
      // function Print(){ , function미사용
      Print() {
        console.log("class 내부 메소드-------------------------");
      }
  
    }
  
    function parentType(){
      let rtnText ="consol 확인";
      demo.innerHTML = rtnText;
      console.clear();
      // 클래스 호출
      let member = new Member("A1","A2","A3" );
  
      console.log(" F1 :", member.fieldA);
      console.log(" Fu1 :", member.functionA);
      console.log(" P1 :", member.PrivateA);
      console.log(" PAA :", member.privateC);
      
      member.fieldA ="A";
      member.functionA ="A";
      member.PrivateA ="A";
      member.privateC ="A";
      console.log("");
      console.log(" F2 :", member.fieldA);
      console.log(" Fu2 :", member.functionA);
      console.log(" P2 :", member.PrivateA);
      console.log(" PAA :", member.privateC);
  
      member.Print();
    }
  
  </script>

<!-- 2 -->
  <script>
    'use stricrt'
    class children extends Member {

      constructor(mem ) {
        this.mem = mem;
      }

      Print(){
        console.log("class children print");
      }

    }

    function childrenType(){
      let rtnText ="consol 확인";
      demo.innerHTML = rtnText;
      console.clear();

      let children = new children("A1","A2","A3" );

    }
  </script>

<!-- 3 -->
<script>
  'use stricrt'
  let newWindowA;
  let newWindowB;

  function WindowCheck(){
    let rtnText ="";
      demo.innerHTML = rtnText;
    console.clear();

    let str = '';

    str += '현재 있는 모니터 기준<br/> (더블 모니터시 해당 창이 있는 모니터 기준 출력) <br/><br/>';
    str += '화면 해상도 가로크기 : ' + window.screen.width + "px<br/>";
    str += '화면 해상도 세로크기 : ' + window.screen.height + "px<br/>";
    str += '사용자 작업영업 가로크기 : ' + window.screen.availWidth + "px<br/>";
    str += '사용자 작업영업 세로크기 : ' + window.screen.availHeight + "px<br/>";
    str += '표현 가능 색상수 : ' + Math.pow(2, screen.colorDepth) + "<br/>";
    str += '픽셀당 표현 가능 색상수 : ' + Math.pow(2, screen.pixelDepth) + "<br/>";

    demo.innerHTML = str;
  }

  function WindowNewOpen(){
    let rtnText ="신규 창을 연다. <br/> ";
      demo.innerHTML = rtnText;
    console.clear();
      // window.open(URL, 윈도우이름, 옵션);
      let url = "./childSite.html";
      let windowName = "";
      let opt = "width=400px, height=350px, top=400px, left=500px";

      newWindowA = window.open(url, windowName, opt);
  }
  function WindowNewClose(){
    let rtnText ="바로 직전의 창을 닫는다. <br/> 그 이전에 열었던 창은 그대로 열려있다.";
      demo.innerHTML = rtnText;
    console.clear();

    newWindowA.close();
  }


  function WindowNewOpen2(){
    let rtnText ="신규 창에 이름을 지정하고 연다. <br/> ";
      demo.innerHTML = rtnText;
    console.clear();

      // window.open(URL, 윈도우이름, 옵션);
      let url = "https://www.naver.com";
      let windowName = "newWindow";
      let opt = "width=400px, height=350px, top=400px, left=500px";

      newWindowB = window.open(url, windowName, opt);
  }

  function WindowNewClose2(){
    let rtnText ="하나의 창을 열때, 지정해준 name의 창이 닫힌다. <br/> ";
      demo.innerHTML = rtnText;
    console.clear();

    newWindowB.close();
  }

</script>

</head>
<body> 
  <!-- 결과 출력 -->
  <div class="demoView">
    <strong style="font-size: 20px;">결과 출력창  &nbsp; &nbsp; &nbsp; &nbsp;
      <input type="button" value="초기화" onclick=" demoReset()">
      <br/><hr/><br/>
    </strong>
  
    <div id="demo"></div>
  </div>

  <p><br/></p>
  <div class="container" style="border: 1px solid black; margin: 20px; padding: 20px">
    <h2>1 클래스 </h2><br/>
    <div  type="button" onclick="parentType() "  class="bgG4 lintH50px" >1.클래스(private) </div>
    <div  type="button" onclick="childrenType() "  class="bgB4 lintH50px" >2.자식 클래스</div>
  </div>


  <div class="container" style="border: 1px solid black; margin: 20px; padding: 20px">
    <h2>2 window 제어 </h2><br/>

    <button type="button" onclick="WindowCheck()" class="btn btn-success">정보 확인</button><br/><br/>
    <button type="button" onclick="WindowNewOpen()" class="btn btn-primary">새창(반복)</button>
    <button type="button" onclick="WindowNewClose()" class="btn btn-success">새창(반복) 닫기</button><br/><br/>
    <button type="button" onclick="WindowNewOpen2()" class="btn btn-primary">새창(하나의 창)</button>
    <button type="button" onclick="WindowNewClose2()" class="btn btn-success">새창(하나의 창) 닫기</button>

  
  </div>

</body>
</html>